/**
 * @fileoverview
 * HTML5 QR code scanning library.
 * - Decode QR Code using web cam or smartphone camera
 *
 * @author mebjas <minhazav@gmail.com>
 *
 * The word "QR Code" is registered trademark of DENSO WAVE INCORPORATED
 * http://www.denso-wave.com/qrcode/faqpatent-e.html
 *
 * Note: ECMA Script is not supported by all browsers. Use minified/html5-qrcode.min.js for better
 * browser support. Alternatively the transpiled code lives in transpiled/html5-qrcode.js
 */
 class Html5Qrcode {
    static DEFAULT_WIDTH = 300;
    static DEFAULT_WIDTH_OFFSET = 2;
    static SCAN_DEFAULT_FPS = 2;
    static MIN_QR_BOX_SIZE = 50;
    static SHADED_LEFT = 1;
    static SHADED_RIGHT = 2;
    static SHADED_TOP = 3;
    static SHADED_BOTTOM = 4;
    static SHADED_REGION_CLASSNAME = "qr-shaded-region";
    static VERBOSE = false;
    static BORDER_SHADER_DEFAULT_COLOR = "#ffffff";
    static BORDER_SHADER_MATCH_COLOR = "rgb(90, 193, 56)";

    /**
     * Initialize QR Code scanner.
     * * @param {String} elementId - Id of the HTML element. 
     * @param {Boolean} verbose - Optional argument, if true, all logs
     * would be printed to console. 
     */
    constructor(elementId, verbose) {
        if (!qrcode) {
            throw 'qrcode is not defined, use the minified/html5-qrcode.min.js for proper support';
        }

        this._elementId = elementId;
        this._foreverScanTimeout = null;
        this._localMediaStream = null;
        this._shouldScan = true;
        this._url = window.URL || window.webkitURL || window.mozURL || window.msURL;
        this._userMedia = navigator.getUserMedia || navigator.webkitGetUserMedia ||
            navigator.mozGetUserMedia || navigator.msGetUserMedia;
        this._isScanning = false;

        Html5Qrcode.VERBOSE = verbose === true;
    }

    /**
     * Start scanning QR Code for given camera.
     * * @param {any} cameraIdOrConfig - Id of the camera to use or object with
     * camera constraints.
     * @param {Object} configuration - Extra configurations to tune QR code
     * scanner.
     * Supported Fields:
     * - fps: expected framerate of qr code scanning. example { fps: 2 }
     * means the scanning would be done every 500 ms.
     * - qrbox: width of QR scanning box, this should be smaller than
     * the width and height of the box. This would make the scanner
     * look like this:
     * ----------------------
     * |********************|
     * |******,,,,,,,,,*****|      <--- shaded region
     * |******|       |*****|      <--- non shaded region would be
     * |******|       |*****|          used for QR code scanning.
     * |******|_______|*****|
     * |********************|
     * |********************|
     * ----------------------
     * - aspectRatio: Optional, aspect ratio of viewfinder.
     * @param {Function} qrCodeSuccessCallback - callback on QR Code found.
     * Example:
     * function(qrCodeMessage) {}
     * @param {Function} qrCodeErrorCallback - callback on QR Code parse error.
     * Example:
     * function(errorMessage) {}
     * * @returns {Promise} - Promise for starting the scan. The Promise can fail
     * if the user doesn't grant permission or some API is not supported by
     * the browser.
     */
    start(
        cameraIdOrConfig,
        configuration,
        qrCodeSuccessCallback,
        qrCodeErrorCallback) {

        if (!cameraIdOrConfig) {
            throw "cameraIdOrConfig is required";
        }

        if (!qrCodeSuccessCallback || typeof qrCodeSuccessCallback != "function") {
            throw "qrCodeSuccessCallback is required and should be a function."
        }

        if (!qrCodeErrorCallback) {
            // Let's not make this mandatory, use console.log as default.
            qrCodeErrorCallback = (errorMessage) => {
                if (Html5Qrcode.VERBOSE) {
                    console.log(errorMessage);
                }
            };
        }

        // Cleanup.
        this._clearElement();
        const config = configuration ? configuration : {};

        // Start scanning.
        return new Promise((resolve, reject) => {
            this.isScanning = true;
            this.shouldScan = true;
            qrcode.callback = (decodedText, other) => {
                return qrCodeSuccessCallback(decodedText, other);
            };

            // Get camera Scan Action
            this.localMediaStream
            const videoConstraints = this.createVideoConstraints(cameraIdOrConfig);
            navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: videoConstraints
                })
                .then(stream => {
                    const videoScanAction = (stream) => {
                        this.localMediaStream = stream;
                        this.startScanning(config)
                            .then(() => {
                                resolve();
                            })
                            .catch(err => {
                                reject(err);
                            });
                    };

                    this.setVideoConstraints(stream, config)
                        .then(newStream => {
                            videoScanAction(stream);
                        })
                        .catch(error => {
                            if (Html5Qrcode.VERBOSE) {
                                console.error(
                                    "Couldn't set video constraints, ignoring.",
                                    error);
                            }
                            videoScanAction(stream);
                        });
                })
                .catch(err => {
                    reject(`Error getting userMedia, error = ${err}`);
                });
        });
    }

    /**
     * Stops streaming QR Code video and scanning.
     *
     * @returns {Promise<any>} A Promise that resolves when the scan is stopped.
     */
    stop() {
        this.shouldScan = false;
        clearTimeout(this.foreverScanTimeout);

        return new Promise((resolve, /* ignore */ reject) => {
            if (!this.isScanning) {
                resolve();
                return;
            }

            qrcode.callback = null;

            if (this.localMediaStream) {
                const tracks = this.localMediaStream.getVideoTracks();
                for (let i = 0; i < tracks.length; i++) {
                    tracks[i].stop();
                }
            }

            this.localMediaStream = null;
            this.clearElement();
            this.isScanning = false;
            resolve();
        });
    }

    /**
     * Scans an Image File for QR Code.
     *
     * This feature is mutually exclusive to camera based scanning, you should
     * call stop() if the camera based scanning was ongoing.
     *
     * @param {File} imageFile a local file with Image content.
     * @param {boolean} showImage if true the Image will be rendered on given
     * element.
     *
     * @returns {Promise} Promise with decoded QR code string on success and
     * error message on failure. Failure could happen due to different reasons:
     * 1. QR Code decode failed because enough patterns not found in image.
     * 2. Input file was not image or unable to load the image or other image
     * load errors.
     */
    scanFile(imageFile, /* default=true */ showImage) {
        if (!imageFile || !(imageFile instanceof File)) {
            throw "imageFile argument is mandatory and should be instance " +
                "of File. Use 'event.target.files[0]'";
        }

        if (showImage === undefined) {
            showImage = true;
        }

        if (this.isScanning) {
            throw "Close ongoing scan before scanning a file.";
        }

        return new Promise((resolve, reject) => {
            this.possiblyCloseLastScanImageFile();
            this.clearElement();
            this.lastScanImageFile = imageFile;

            const inputImage = new Image;
            const $this = this;
            const imageLoadErrorHandler = (event) => {
                reject(event);
            };

            inputImage.onload = () => {
                const imageWidth = inputImage.width;
                const imageHeight = inputImage.height;
                const element = document.getElementById(this.elementId);

                const containerWidth = element.clientWidth ?
                    element.clientWidth :
                    imageWidth;
                const containerHeight = element.clientHeight ?
                    element.clientHeight :
                    imageHeight;
                const canvasDrawConfig = {
                    x: 0,
                    y: 0,
                    width: containerWidth,
                    height: containerHeight
                };

                if (showImage) {
                    const visibleCanvas = this.createCanvasElement(
                        containerWidth,
                        containerHeight,
                        'qr-canvas-visible');
                    visibleCanvas.style.display = "inline-block";
                    element.appendChild(visibleCanvas);
                    const context = visibleCanvas.getContext('2d');
                    context.canvas.width = containerWidth;
                    context.canvas.height = containerHeight;
                    context.drawImage(
                        inputImage, 0, 0, imageWidth, imageHeight,
                        canvasDrawConfig.x, canvasDrawConfig.y,
                        canvasDrawConfig.width, canvasDrawConfig.height);
                }

                const hiddenCanvas = this.createCanvasElement(imageWidth, imageHeight);
                element.appendChild(hiddenCanvas);
                const context = hiddenCanvas.getContext('2d');
                context.canvas.width = imageWidth;
                context.canvas.height = imageHeight;
                context.drawImage(inputImage, 0, 0);

                qrcode.callback = (result, other) => {
                    return resolve(result, other);
                };
                try {
                    qrcode.decode();
                } catch (exception) {
                    reject(`QR code parse error, error = ${exception}`);
                }
            };

            inputImage.onerror = imageLoadErrorHandler;
            inputImage.onabort = imageLoadErrorHandler;
            inputImage.onstalled = imageLoadErrorHandler;
            inputImage.onsuspend = imageLoadErrorHandler;
            inputImage.src = URL.createObjectURL(imageFile);
        });
    }

    /**
     * Clears the existing canvas.
     *
     * Note: in case of ongoing web cam based scan, it needs to be explicitly
     * closed before calling this method, else it will throw exception.
     */
    clear() {
        this.clearElement();
    }

    /**
     * Returns a Promise with list of all cameras supported by the device.
     *
     * The returned object is a list of result object of type:
     * [{
     * id: String;     // Id of the camera.
     * label: String;  // Human readable name of the camera.
     * }]
     */
    static getCameras() {
        return new Promise((resolve, reject) => {
            if (navigator.mediaDevices &&
                navigator.mediaDevices.enumerateDevices &&
                navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({
                        audio: false,
                        video: true
                    })
                    .then(stream => {
                        const closeActiveStreams = stream => {
                            const tracks = stream.getVideoTracks();
                            for (let i = 0; i < tracks.length; i++) {
                                const track = tracks[i];
                                track.enabled = false;
                                track.stop();
                                stream.removeTrack(track);
                            }
                        };

                        navigator.mediaDevices.enumerateDevices()
                            .then(devices => {
                                let results = [];
                                devices.forEach((device) => {
                                    if (device.kind === "videoinput") {
                                        results.push({
                                            id: device.deviceId,
                                            label: device.label
                                        });
                                    }
                                });
                                closeActiveStreams(stream);
                                resolve(results);
                            })
                            .catch(err => {
                                reject(`${err.name} : ${err.message}`);
                            });
                    })
                    .catch(err => {
                        reject(`${err.name} : ${err.message}`);
                    });
            } else if (MediaStreamTrack && MediaStreamTrack.getSources) {
                const callback = sourceInfos => {
                    let results = [];
                    for (var i = 0; i !== sourceInfos.length; ++i) {
                        const sourceInfo = sourceInfos[i];
                        if (sourceInfo.kind === 'video') {
                            results.push({
                                id: sourceInfo.id,
                                label: sourceInfo.label
                            });
                        }
                    }
                    resolve(results);
                }
                MediaStreamTrack.getSources(callback);
            } else {
                reject("enumerateDevices() not supported.");
            }
        });
    }

    /**
     * Returns the capabilities of the running video track.
     *
     * @returns {MediaTrackCapabilities} a MediaTrackCapabilities object.
     * @throws error if the scanning is not in running state.
     */
    getRunningTrackCapabilities() {
        if (this.localMediaStream == null) {
            throw "Scanning is not running.";
        }
        const videoTracks = this.localMediaStream.getVideoTracks();
        if (videoTracks.length == 0) {
            throw "No video tracks found";
        }
        return videoTracks[0].getCapabilities();
    }

    /**
     * Apply a video constraints on running video track.
     *
     * @param {MediaTrackConstraints} A MediaTrackConstraints object.
     * @returns a Promise that resolves when the constraints are applied.
     * @throws error if the scanning is not in running state.
     */
    applyVideoConstraints(videoConstaints) {
        if (!videoConstaints || typeof videoConstaints != "object") {
            throw "videoConstaints should be an object.";
        }

        if (this.localMediaStream == null) {
            throw "Scanning is not running.";
        }

        const videoTracks = this.localMediaStream.getVideoTracks();
        if (videoTracks.length == 0) {
            throw "No video tracks found";
        }

        return new Promise((resolve, reject) => {
            videoTracks[0].applyConstraints(videoConstaints)
                .then(result => {
                    resolve(result);
                })
                .catch(error => {
                    reject(error);
                });
        });
    }

    //#region private methods
    /**
     * Sets the video constraints during runtime.
     *
     * @param {MediaStream} stream
     * @param {Object} config
     */
    setVideoConstraints(stream, config) {
        return new Promise((resolve, reject) => {
            if (config.aspectRatio) {
                const videoTracks = stream.getVideoTracks();
                const existingConstraints = videoTracks[0].getConstraints();
                existingConstraints.aspectRatio = config.aspectRatio;

                if (this.verbose) {
                    console.log("Applying aspect ratio: " + config.aspectRatio);
                }
                stream.getVideoTracks()[0].applyConstraints(existingConstraints)
                    .then(result => {
                        if (this.verbose) {
                            console.log("aspect ratio applied.");
                        }
                        resolve(result);
                    })
                    .catch(error => {
                        if (this.verbose) {
                            console.warn("Unable to apply aspect ratio.", error);
                        }
                        resolve(error);
                    })
            } else {
                resolve(null);
            }
        });
    }

    /**
     * Create video constraints object.
     *
     * @param {Object} cameraIdOrConfig
     */
    createVideoConstraints(cameraIdOrConfig) {
        if (typeof cameraIdOrConfig == "object") {
            return cameraIdOrConfig;
        }

        let videoConstraints = true;
        if (typeof cameraIdOrConfig == "string") {
            videoConstraints = {
                deviceId: {
                    exact: cameraIdOrConfig
                }
            };
        } else if (typeof cameraIdOrConfig == 'object' &&
            cameraIdOrConfig.facingMode) {
            videoConstraints = {
                facingMode: cameraIdOrConfig.facingMode
            };
        } else if (typeof cameraIdOrConfig == 'object' &&
            cameraIdOrConfig.deviceId) {
            videoConstraints = {
                deviceId: cameraIdOrConfig.deviceId
            };
        }
        return videoConstraints;
    }

    startScanning(config) {
        this.element = document.getElementById(this.elementId);
        this.videoElement = this.createVideoElement();
        this.element.appendChild(this.videoElement);
        this.videoElement.srcObject = this.localMediaStream;

        return new Promise((resolve, reject) => {
            this.videoElement.onabort = reject;
            this.videoElement.onerror = reject;
            this.videoElement.onplaying = () => {
                const videoWidth = this.videoElement.clientWidth;
                const videoHeight = this.videoElement.clientHeight;

                if (!config.qrbox) {
                    const smallerEdge = Math.min(videoWidth, videoHeight);
                    const qrboxSize = Math.floor(smallerEdge * 0.8);
                    this.qrbox = qrboxSize;
                } else {
                    this.qrbox = config.qrbox;
                }

                if (this.qrbox < 60) {
                    this.qrbox = 60;
                }

                const qrboxSize = this.qrbox;
                this.setupUi(videoWidth, videoHeight, qrboxSize);
                const foreverScan = () => {
                    if (!this.shouldScan) {
                        return;
                    }
                    try {
                        const scanRegion = this.getScanRegion(
                            videoWidth, videoHeight, qrboxSize);
                        this.context.drawImage(
                            this.videoElement,
                            scanRegion.x, scanRegion.y,
                            scanRegion.width, scanRegion.height,
                            0, 0,
                            scanRegion.width, scanRegion.height);
                        qrcode.decode();
                        this.possiblyUpdateShaders(true);
                    } catch (exception) {
                        this.possiblyUpdateShaders(false);
                    } finally {
                        const fps = config.fps ? config.fps : 2;
                        const timeout = this.getTimeoutFps(fps);
                        this.foreverScanTimeout = setTimeout(foreverScan, timeout);
                    }
                };

                foreverScan();
                resolve(true);
            };
        });
    }

    clearElement() {
        if (this.isScanning) {
            throw 'Cannot clear while scan is ongoing, close it first.';
        }
        const element = document.getElementById(this.elementId);
        element.innerHTML = "";
        element.style.position = null;
    }

    createVideoElement() {
        const videoElement = document.createElement('video');
        videoElement.style.width = "100%";
        videoElement.style.height = "100%";
        videoElement.playsInline = true;
        videoElement.muted = true;
        videoElement.autoplay = true;
        videoElement.id = "html5-qrcode-video";
        return videoElement;
    }

    setupUi(width, height, qrboxSize) {
        const canvasWidth = qrboxSize;
        const canvasHeight = qrboxSize;
        const canvasElement = this.createCanvasElement(canvasWidth, canvasHeight);
        this.element.append(canvasElement);
        this.context = canvasElement.getContext('2d');
        this.possiblyInsertShaders(width, height, qrboxSize);
    }

    createCanvasElement(width, height, customId) {
        const canvasElement = document.createElement('canvas');
        canvasElement.style.width = `${width}px`;
        canvasElement.style.height = `${height}px`;
        canvasElement.style.display = "none";
        canvasElement.id = customId === undefined ? 'qr-canvas' : customId;
        return canvasElement;
    }

    getScanRegion(videoWidth, videoHeight, qrboxSize) {
        const regionX = (videoWidth - qrboxSize) / 2;
        const regionY = (videoHeight - qrboxSize) / 2;
        return {
            x: regionX,
            y: regionY,
            width: qrboxSize,
            height: qrboxSize
        }
    }

    getTimeoutFps(fps) {
        return 1000 / fps;
    }

    possiblyInsertShaders(videoWidth, videoHeight, qrboxSize) {
        const qrboxX = (videoWidth - qrboxSize) / 2;
        const shadedRegionWidth = qrboxX;
        const shadedRegionLeft = this.createShadedRegion(
            shadedRegionWidth, videoHeight, "#0000007a");
        this.element.appendChild(shadedRegionLeft);

        const shadedRegionRight = this.createShadedRegion(
            shadedRegionWidth, videoHeight, "#0000007a");
        shadedRegionRight.style.left = (videoWidth - shadedRegionWidth) + "px";
        this.element.appendChild(shadedRegionRight);

        const topShadeHeight = (videoHeight - qrboxSize) / 2;
        const topShade = document.createElement('div');
        topShade.style.position = "absolute";
        topShade.style.top = 0;
        topShade.style.left = qrboxX + "px";
        topShade.style.height = topShadeHeight + "px";
        topShade.style.width = qrboxSize + "px";
        topShade.style.background = "#0000007a";
        this.element.appendChild(topShade);

        const bottomShade = document.createElement('div');
        bottomShade.style.position = "absolute";
        bottomShade.style.top = (videoHeight + qrboxSize) / 2 + "px";
        bottomShade.style.left = qrboxX + "px";
        bottomShade.style.height = topShadeHeight + "px";
        bottomShade.style.width = qrboxSize + "px";
        bottomShade.style.background = "#0000007a";
        this.element.appendChild(bottomShade);

        const highlightDiv = document.createElement('div');
        highlightDiv.className = "scan-region-highlight-style";
        highlightDiv.style.position = "absolute";
        highlightDiv.style.border = "4px solid white";
        highlightDiv.style.width = (qrboxSize - 8) + "px";
        highlightDiv.style.height = (qrboxSize - 8) + "px";
        highlightDiv.style.top = (videoHeight - qrboxSize) / 2 + "px";
        highlightDiv.style.left = (videoWidth - qrboxSize) / 2 + "px";
        highlightDiv.style.zIndex = 1;
        this.element.appendChild(highlightDiv);
    }

    createShadedRegion(width, height, color) {
        const shadedRegion = document.createElement('div');
        shadedRegion.style.position = "absolute";
        shadedRegion.style.top = 0;
        shadedRegion.style.left = 0;
        shadedRegion.style.height = height + "px";
        shadedRegion.style.width = width + "px";
        shadedRegion.style.background = color;
        return shadedRegion;
    }

    possiblyUpdateShaders(qrMatch) {
        const highlightDiv = document.getElementsByClassName(
            "scan-region-highlight-style");
        if (highlightDiv.length == 0) {
            return;
        }

        if (qrMatch) {
            highlightDiv[0].style.borderColor = "#62d162";
        } else {
            highlightDiv[0].style.borderColor = "white";
        }
    }

    possiblyCloseLastScanImageFile() {
        if (this.lastScanImageFile) {
            URL.revokeObjectURL(this.lastScanImageFile);
        }
    }
}

class Html5QrcodeScanner {

    constructor(elementId, config, verbose) {
        this.elementId = elementId;
        this.config = config;
        this.verbose = verbose === undefined ? true : verbose;

        if (!this.elementId) {
            throw "elementId cannot be null or undefined";
        }

        if (!Html5QrcodeScanner.isValidHtml5QrcodeSupportedFormats(
                this.config ? this.config.formatsToSupport : undefined)) {
            throw "'formatsToSupport' must be undefined or an array of " +
                "'Html5QrcodeSupportedFormats'.";
        }
        this.sectionState = Html5QrcodeScannerStatus.STATUS_DEFAULT;
        this.html5Qrcode = null;
    }
    render(qrCodeSuccessCallback, qrCodeErrorCallback) {
        const $this = this;
        const renderAction = () => {
            if ($this.sectionState === Html5QrcodeScannerStatus.STATUS_DEFAULT) {
                return $this.renderInitialScanState(
                    qrCodeSuccessCallback, qrCodeErrorCallback);
            } else if ($this.sectionState
                === Html5QrcodeScannerStatus.STATUS_SCANNING) {
                throw "Cannot render when scan is in progress.";
            } else if ($this.sectionState
                === Html5QrcodeScannerStatus.STATUS_SUCCESS) {
                $this.renderSuccessState($this.lastMatch);
                $this.renderInitialScanState(
                    qrCodeSuccessCallback, qrCodeErrorCallback);
            } else {
                throw "Rendered in wrong state: " + $this.sectionState;
            }
        }

        this.sectionState = Html5QrcodeScannerStatus.STATUS_DEFAULT;
        this.renderInitialScanState(qrCodeSuccessCallback, qrCodeErrorCallback);
    }

    clear() {
        const $this = this;
        const element = document.getElementById(this.elementId);
        if (element) {
            element.innerHTML = "";
            const scannerAction = () => {
                if ($this.html5Qrcode) {
                    $this.html5Qrcode.stop().then(() => {
                        $this.html5Qrcode.clear();
                        $this.html5Qrcode = null;
                    }).catch(error => {
                        if ($this.verbose) {
                            console.error("Failed to stop html5Qrcode.");
                        }
                    });
                }
            }
            scannerAction();
        }
    }

    getRunningTrackCapabilities() {
        if (this.html5Qrcode == null) {
            throw "Scanner not initialized.";
        }
        return this.html5Qrcode.getRunningTrackCapabilities();
    }

    applyVideoConstraints(videoConstaints) {
        if (this.html5Qrcode == null) {
            throw "Scanner not initialized.";
        }
        return this.html5Qrcode.applyVideoConstraints(videoConstaints);
    }

    createConfigForScan() {
        let config = {};
        if (this.config) {
            if (this.config.fps) {
                config.fps = this.config.fps;
            }

            if (this.config.qrbox) {
                config.qrbox = this.config.qrbox;
            }

            if (this.config.aspectRatio) {
                config.aspectRatio = this.config.aspectRatio;
            }

            if (this.config.disableFlip !== undefined) {
                config.disableFlip = this.config.disableFlip;
            }

            if (this.config.videoConstraints) {
                config.videoConstraints = this.config.videoConstraints;
                return config;
            }

            const formatsToSupport = this.config.formatsToSupport;
            if (formatsToSupport) {
                if (!Array.isArray(formatsToSupport)) {
                    const typeofFormats = typeof formatsToSupport;
                    throw "formatsToSupport should be an array, found " +
                        `${typeofFormats}`;
                }

                if (formatsToSupport.length === 0) {
                    throw "formatsToSupport should have atleast 1 format."
                }

                formatsToSupport.forEach(format => {
                    if (!Object.values(Html5QrcodeSupportedFormats)
                        .includes(format)) {
                        throw `${format} is not a supported format.`;
                    }
                });
            }
        }
        return config;
    }

    renderInitialScanState(
        qrCodeSuccessCallback,
        qrCodeErrorCallback) {
        const $this = this;
        const parentElement = document.getElementById(this.elementId);
        parentElement.innerHTML = "";

        const container = document.createElement('div');
        container.style.textAlign = "center";
        parentElement.appendChild(container);

        const previewElement = document.createElement('div');
        const qrboxSize = this.config && this.config.qrbox ?
            this.config.qrbox :
            250;
        previewElement.id = "html5-qrcode-preview-element";
        previewElement.style.width = qrboxSize + "px";
        previewElement.style.height = qrboxSize + "px";
        previewElement.style.border = "1px solid silver";
        previewElement.style.margin = "0px auto";
        container.appendChild(previewElement);

        const button = document.createElement('button');
        
        function scan(cameraId) {
            if ($this.sectionState === Html5QrcodeScannerStatus.STATUS_SCANNING) {
                if ($this.verbose) {
                    console.error(
                        "Scan is already in progress, cannot start new scan.");
                }
                return;
            }

            const config = $this.createConfigForScan();
            $this.html5Qrcode = new Html5Qrcode(previewElement.id, $this.verbose);
            $this.sectionState = Html5QrcodeScannerStatus.STATUS_SCANNING;
            button.disabled = true;

            $this.html5Qrcode.start(
                cameraId,
                config,
                (decodedText) => {
                    $this.sectionState = Html5QrcodeScannerStatus.STATUS_SUCCESS;
                    $this.lastMatch = decodedText;
                    qrCodeSuccessCallback(decodedText);
                    $this.clear();
                },
                (errorMessage) => {
                    if ($this.verbose) {
                        console.log("qr code scan error", errorMessage);
                    }
                    if (qrCodeErrorCallback) {
                        qrCodeErrorCallback(errorMessage);
                    }
                }
            )
        }
        button.innerHTML = "Scan using camera";
        container.appendChild(document.createElement('br'));
        container.appendChild(button);
        button.addEventListener('click', async () => {
            if (0 === (await o.Html5Qrcode.getCameras()).length)
                return void alert("No camera found");
            button.disabled = !0;
            var e = document.createElement("span");
            e.innerHTML = "Select camera: ",
                u.appendChild(e);
            var n = document.createElement("select");
            e.forEach(function(t) {
                var e = document.createElement("option");
                e.value = t.id,
                    e.innerHTML = t.label ? t.label : t.id,
                    n.appendChild(e)
            }),
            u.appendChild(n),
                n.addEventListener("change", function() {
                    var e = n.value;
                    p(e)
                }),
                p(e[0].id)
        });
    }
}


class Html5QrcodeScannerStatus {
    static STATUS_DEFAULT = "STATUS_DEFAULT";
    static STATUS_SUCCESS = "STATUS_SUCCESS";
    static STATUS_SCANNING = "STATUS_SCANNING";
}

class Html5QrcodeSupportedFormats {
    static QR_CODE = "QR_CODE";
    static AZTEC = "AZTEC";
    static CODABAR = "CODABAR";
    static CODE_39 = "CODE_39";
    static CODE_93 = "CODE_93";
    static CODE_128 = "CODE_128";
    static DATA_MATRIX = "DATA_MATRIX";
    static MAXICODE = "MAXICODE";
    static ITF = "ITF";
    static EAN_13 = "EAN_13";
    static EAN_8 = "EAN_8";
    static PDF_417 = "PDF_417";
    static RSS_14 = "RSS_14";
    static RSS_EXPANDED = "RSS_EXPANDED";
    static UPC_A = "UPC_A";
    static UPC_E = "UPC_E";
    static UPC_EAN_EXTENSION = "UPC_EAN_EXTENSION";
}

function isValidHtml5QrcodeSupportedFormats(formatsToSupport) {
    if (!formatsToSupport) {
        return true;
    }

    if (!Array.isArray(formatsToSupport)) {
        return false;
    }

    let supportedFormats = new Set();
    for (const format in formatsToSupport) {
        const supportedFormat = formatsToSupport[format];
        if (supportedFormats.has(supportedFormat)) {
            console.warn(`${supportedFormat} is specified multiple times, ignoring.`);
        } else {
            supportedFormats.add(supportedFormat);
        }
    }
    return true;
}
</script>
    
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            const resultContainer = document.getElementById('result');

            function onScanSuccess(decodedText, decodedResult) {
                resultContainer.innerHTML = `<span class="success">âœ… Scan Berhasil! Mengalihkan...</span>`;
                html5QrcodeScanner.clear();
                window.location.href = `process_scan.php?data=${decodedText}`;
            }

            function onScanFailure(error) {
                // Biarkan kosong agar tidak menampilkan error berulang
            }

            let html5QrcodeScanner = new Html5QrcodeScanner(
                "reader", 
                { 
                    fps: 10,
                    qrbox: 250
                },
                false); // 'false' berarti verbose mode dimatikan
            
            html5QrcodeScanner.render(onScanSuccess, onScanFailure);
        });
    </script>

</body>
</html>